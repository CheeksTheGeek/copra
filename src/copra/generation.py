from __future__ import annotations

from pathlib import Path
from textwrap import indent
from typing import Dict, List, Set, Any

from .discovery import HierarchyDict

_sanitize_name = lambda name: ''.join(word.capitalize() for word in name.split('[')[0].split('_'))  # type: ignore

def generate_stub(hierarchy: HierarchyDict, out_dir: Path) -> Path:
    """Generate stub file from HierarchyDict with proper cocotb types."""
    lines: list[str] = [
        "from __future__ import annotations",
        "from typing import Any",
        "import cocotb.handle",
        "import cocotb.types",
        "",
        "# This file was automatically generated by copra",
        "# It provides type stubs for your HDL design for use with cocotb",
        "",
    ]
    
    tree = hierarchy.get_tree()
    
    if not tree:
        lines.extend([
            "class DUT(cocotb.handle.HierarchyObject):",
            "    pass",
            "",
        ])
    else:
        top_tree = tree[list(tree.keys())[0]]
        top_node = top_tree.get("_node")
        
        base_class = "HierarchyObject"
        if top_node and "HierarchyArrayObject" in top_node.py_type:
            base_class = "HierarchyArrayObject"
        
        lines.append(f"class DUT(cocotb.handle.{base_class}):")
        children = top_tree.get("_children", {})
        if not children:
            lines.append("    pass")
        else:
            for child_name, child_tree in children.items():
                if child_name.endswith(']'):
                    continue
                if (child_node := child_tree.get("_node")):
                    lines.append(indent(
                        f"{child_name}: {_sanitize_name(child_name) if child_node.is_scope else child_node.py_type}"
                        f"{' # Indexable array' if child_node.is_scope and 'HierarchyArrayObject' in child_node.py_type else ''}",
                        "    "
                    ))
        lines.append("")
        generated_classes: Set[str] = set()
        _generate_all_classes(tree, lines, generated_classes)
    
    out_dir.mkdir(parents=True, exist_ok=True)
    text = "\n".join(lines)
    stub_path = out_dir / "dut.pyi"
    stub_path.write_text(text)
    return stub_path

def _generate_all_classes(tree: Dict[str, Any], lines: List[str], generated_classes: Set[str]) -> None:
    """Generate all class definitions by walking the tree."""
    for name, subtree in tree.items():
        node = subtree.get("_node")
        children = subtree.get("_children", {})
        
        if node and node.is_scope and children:
            class_name = _sanitize_name(name)
            if class_name not in generated_classes:
                generated_classes.add(class_name)
                base_class = "HierarchyObject"
                if "HierarchyArrayObject" in node.py_type:
                    base_class = "HierarchyArrayObject"
                lines.append(f"class {class_name}(cocotb.handle.{base_class}):")
                for child_name, child_tree in children.items():
                    if '[' in child_name and ']' in child_name: 
                        continue
                    child_node = child_tree.get("_node")
                    if child_node:
                        if child_node.is_scope:
                            child_class_name = _sanitize_name(child_name)
                            if "HierarchyArrayObject" in child_node.py_type:
                                lines.append(indent(f"{child_name}: {child_class_name}  # Indexable array", "    "))
                            else:
                                lines.append(indent(f"{child_name}: {child_class_name}", "    "))
                        else:
                            lines.append(indent(f"{child_name}: {child_node.py_type}", "    "))
                lines.append("")
        _generate_all_classes(children, lines, generated_classes)
