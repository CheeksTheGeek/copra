from __future__ import annotations

import os
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Set, Pattern
import re

@dataclass
class HDLConfig:
    """Configuration for HDL file discovery and parsing."""
    verilog_extensions: Set[str] = field(default_factory=lambda: {'.sv', '.v'})
    vhdl_extensions: Set[str] = field(default_factory=lambda: {'.vhd', '.vhdl'})
    rtl_directory_names: List[str] = field(default_factory=lambda: ['rtl', 'hdl'])
    
    @property
    def all_extensions(self) -> Set[str]:
        return self.verilog_extensions | self.vhdl_extensions
    
    def get_module_patterns(self) -> Dict[str, Pattern[str]]:
        return {
            'verilog': re.compile(r'^\s*module\s+(\w+)', re.MULTILINE),
            'vhdl': re.compile(r'^\s*entity\s+(\w+)\s+is', re.MULTILINE | re.IGNORECASE)
        }
    
    def is_verilog(self, file_path: Path) -> bool:
        return file_path.suffix in self.verilog_extensions
    
    def is_vhdl(self, file_path: Path) -> bool:
        return file_path.suffix in self.vhdl_extensions

@dataclass 
class SimulatorConfig:
    """Configuration for simulator integration."""
    preferred_simulators: List[str] = field(default_factory=lambda: ['verilator', 'icarus', 'questa'])
    build_args: Dict[str, List[str]] = field(default_factory=lambda: {
        'verilator': ['-Wno-fatal', '-Wno-WIDTHTRUNC', '-Wno-WIDTHEXPAND', '-Wno-CASEINCOMPLETE'],
        'icarus': [],
        'questa': []
    })
    env_vars: Dict[str, Dict[str, str]] = field(default_factory=lambda: {
        'verilator': {'CXXFLAGS': '-std=c++14', 'EXTRA_CXXFLAGS': '-std=c++14'},
        'icarus': {},
        'questa': {}
    })
    language_support: Dict[str, List[str]] = field(default_factory=lambda: {
        'verilator': ['verilog'],
        'icarus': ['verilog'], 
        'questa': ['verilog', 'vhdl'],
        'ghdl': ['vhdl']
    })
    
    def supports_language(self, simulator: str, language: str) -> bool:
        """Check if a simulator supports a specific HDL language."""
        return language in self.language_support.get(simulator, [])

@dataclass
class TypeConfig:
    """Configuration for type mappings and generation."""
    import_statements: List[str] = field(default_factory=lambda: [
        'from __future__ import annotations',
        'from typing import Any',
        'import cocotb.handle',
        'import cocotb.types'
    ])
    
    base_classes: Dict[str, str] = field(default_factory=lambda: {
        'hierarchy': 'cocotb.handle.HierarchyObject',
        'hierarchy_array': 'cocotb.handle.HierarchyArrayObject',
        'array': 'cocotb.handle.ArrayObject',
        'logic': 'cocotb.handle.LogicObject',
        'logic_array': 'cocotb.handle.LogicArrayObject',
        'integer': 'cocotb.handle.IntegerObject',
        'real': 'cocotb.handle.RealObject',
        'enum': 'cocotb.handle.EnumObject',
        'string': 'cocotb.handle.StringObject'
    })
    
    value_types: Dict[str, str] = field(default_factory=lambda: {
        'logic': 'cocotb.types.Logic',
        'logic_array': 'cocotb.types.LogicArray',
        'integer': 'int',
        'real': 'float',
        'string': 'bytes',
        'enum': 'str'
    })
    
    fallback_types: Dict[str, str] = field(default_factory=lambda: {
        'value': 'Any',
        'handle': 'cocotb.handle.ValueObjectBase[Any, Any]',
        'base': 'cocotb.handle.SimHandleBase'
    })

@dataclass
class DiscoveryConfig:
    """Configuration for hierarchy discovery."""
    max_depth: int = 50
    scope_types: Set[str] = field(default_factory=lambda: {'MODULE', 'STRUCTURE', 'GENARRAY', 'PACKAGE'})
    array_types: Set[str] = field(default_factory=lambda: {'NETARRAY'})
    generate_prefixes: List[str] = field(default_factory=lambda: ['gen_'])

@dataclass
class OutputConfig:
    """Configuration for output generation."""
    default_stub_dir: str = 'copra_stubs'
    stub_filename: str = 'dut.pyi'
    root_class_name: str = 'DUT'
    env_var_stub_dir: str = 'COPRA_STUB_DIR'
    temp_prefix: str = 'copra_'
    header_lines: List[str] = field(default_factory=lambda: [
        'This file was automatically generated by copra',
        'It provides type stubs for your HDL design for use with cocotb'
    ])

@dataclass
class CopraConfig:
    """Main configuration container for the entire copra system."""
    hdl: HDLConfig = field(default_factory=HDLConfig)
    simulator: SimulatorConfig = field(default_factory=SimulatorConfig)
    types: TypeConfig = field(default_factory=TypeConfig)
    discovery: DiscoveryConfig = field(default_factory=DiscoveryConfig)
    output: OutputConfig = field(default_factory=OutputConfig)
    
    @classmethod
    def from_env(cls) -> 'CopraConfig':
        config = cls()
        
        if stub_dir := os.getenv('COPRA_STUB_DIR'):
            config.output.default_stub_dir = stub_dir
        
        if max_depth := os.getenv('COPRA_MAX_DEPTH'):
            try:
                config.discovery.max_depth = int(max_depth)
            except ValueError:
                pass
        
        if temp_prefix := os.getenv('COPRA_TEMP_PREFIX'):
            config.output.temp_prefix = temp_prefix
            
        return config
    
    def get_simulator_runner(self, simulator_name: Optional[str] = None):
        """Get a simulator runner, preferring the specified one or falling back to available."""
        try:
            from cocotb_tools.runner import get_runner
        except ImportError:
            raise ImportError("cocotb_tools is required for simulator integration")
        
        # Check simulator_name first, then SIM environment variable, then fallback to preferred
        sim_to_use = simulator_name or os.getenv('SIM')
        
        if sim_to_use:
            try:
                return get_runner(sim_to_use)
            except Exception as e:
                if simulator_name:
                    # If explicitly specified, fail fast
                    raise RuntimeError(f"Failed to initialize specified simulator '{sim_to_use}': {e}")
                # If from environment, continue to fallback
        
        for sim in self.simulator.preferred_simulators:
            try:
                return get_runner(sim)
            except Exception:
                continue
        
        raise RuntimeError(f"No supported simulators available from: {self.simulator.preferred_simulators}")

def get_config() -> CopraConfig:
    """Get the global configuration instance."""
    return CopraConfig.from_env() 
